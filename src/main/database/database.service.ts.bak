import { app } from 'electron';
import betterSqlite3 from 'better-sqlite3';

// Interface for color objects
export interface Color {
    id: number;
    name: string;
    is_default: number;
    created_at?: string;
}

export class DatabaseService {
    private db: betterSqlite3.Database | null = null;
    private isInitialized: boolean = false;
    private static instance: DatabaseService | null = null;

    // Private constructor to enforce singleton pattern
    private constructor() {}

    /**
     * Get the singleton instance of DatabaseService
     */
    public static getInstance(): DatabaseService {
        if (!DatabaseService.instance) {
            DatabaseService.instance = new DatabaseService();
        }
        return DatabaseService.instance;
    }

    /**
     * Initialize the database connection and schema
     */
    public async initialize(): Promise<void> {
        if (this.isInitialized) {
            console.log('[DatabaseService] Database already initialized');
            return;
        }

        const dbPath = app.getPath('userData') + '/focusnote.db';
        
        try {
            console.log(`[DatabaseService] Opening database at: ${dbPath}`);
            
            // Initialize the database connection
            this.db = betterSqlite3(dbPath);
            
            // Enable WAL mode and foreign keys for better performance and consistency
            this.db.pragma('journal_mode = WAL');
            this.db.pragma('foreign_keys = ON');
            
            console.log('[DatabaseService] Database connection established');
            
            // Initialize the database schema
            await this.initializeDatabase();
            
            // Mark as initialized
            this.isInitialized = true;
            console.log('[DatabaseService] Database service fully initialized');
        } catch (error) {
            console.error('[DatabaseService] Error initializing database:', error);
            
            // Close the database connection if it was opened
            if (this.db) {
                try {
                    this.db.close();
                    this.db = null;
                } catch (closeError) {
                    console.error('[DatabaseService] Error closing database after failed initialization:', closeError);
                }
            }
            
            throw error;
        }
    }
    
    /**
     * Get all colors from the database
     */
    public getAllColors(): Color[] {
        if (!this.db) {
            throw new Error('Database not initialized');
        }
        
        try {
            const stmt = this.db.prepare('SELECT * FROM colors ORDER BY id');
            return stmt.all() as Color[];
        } catch (error) {
            console.error('[DatabaseService] Error getting colors:', error);
            throw error;
        }
    }
    
    /**
     * Get a color by ID
     */
    public getColorById(id: number): Color | undefined {
        if (!this.db) {
            throw new Error('Database not initialized');
        }
        
        try {
            const stmt = this.db.prepare('SELECT * FROM colors WHERE id = ?');
            return stmt.get(id) as Color | undefined;
        } catch (error) {
            console.error(`[DatabaseService] Error getting color with id ${id}:`, error);
            throw error;
        }
    }

    /**
     * Get the database instance
     * @throws Error if the database is not initialized
     */
    public getDb(): betterSqlite3.Database {
        if (!this.isInitialized || !this.db) {
            throw new Error('Database service has not been initialized');
        }
        return this.db;
    }

    /**
     * Check if the database is initialized
     */
    public isDbInitialized(): boolean {
        return this.isInitialized && this.db !== null;
    }

    /**
     * Close the database connection
     */
    public close(): void {
        if (this.db) {
            try {
                this.db.close();
                console.log('[DatabaseService] Database connection closed');
            } catch (error) {
                console.error('[DatabaseService] Error closing database:', error);
            } finally {
                this.db = null;
                this.isInitialized = false;
            }
        }
    }

    /**
     * Initialize the database schema and default data
     */
    private async initializeDatabase(): Promise<void> {
        if (!this.db) {
            throw new Error('Database not initialized');
        }
        
        console.log('[DatabaseService] Initializing database schema...');
        
        try {
            // Create colors table if it doesn't exist
            this.db.exec(`
                CREATE TABLE IF NOT EXISTS colors (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL CHECK(length(name) <= 20),
                    is_default BOOLEAN DEFAULT 0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(name)
                )
            `);
            
            console.log('[DatabaseService] Colors table created or already exists');
            
            // Insert default colors if they don't exist
            await this.insertDefaultColors();
            
            console.log('[DatabaseService] Database schema initialized successfully');
        } catch (error) {
            console.error('[DatabaseService] Error initializing database schema:', error);
            throw error;
        }
    }

    /**
     * Insert default colors into the database if they don't exist
     */
    private async insertDefaultColors(): Promise<void> {
        if (!this.db) {
            throw new Error('Database not initialized');
        }
        
        try {
            console.log('[DatabaseService] Checking for default colors...');
            
            // Check if we already have colors
            const countStmt = this.db.prepare('SELECT COUNT(*) as count FROM colors');
            const result = countStmt.get() as { count: number };
            
            if (result.count === 0) {
                console.log('[DatabaseService] No colors found, inserting default colors...');
                
                // Insert default colors
                const insertStmt = this.db.prepare(
                    'INSERT INTO colors (name, is_default) VALUES (?, ?)'
                );
                
                const defaultColors = [
                    { name: 'Red', is_default: 1 },
                    { name: 'Blue', is_default: 1 },
                    { name: 'Green', is_default: 1 },
                    { name: 'Yellow', is_default: 1 },
                    { name: 'Purple', is_default: 1 }
                ];
                
                // Use a transaction for inserting all default colors
                const insertTransaction = this.db.transaction((colors: Array<{name: string, is_default: number}>) => {
                    for (const color of colors) {
                        insertStmt.run(color.name, color.is_default);
                    }
                });
                
                insertTransaction(defaultColors);
                console.log(`[DatabaseService] Inserted ${defaultColors.length} default colors`);
            } else {
                console.log(`[DatabaseService] Found ${result.count} existing colors, skipping default insertion`);
            }
        } catch (error) {
            console.error('[DatabaseService] Error inserting default colors:', error);
            throw error;
        }
    }

        // Insert default colors if the table is empty
        const count = this.db.prepare('SELECT COUNT(*) as count FROM colors').get() as { count: number };
        if (count.count === 0) {
            console.log('[DatabaseService] Inserting default colors...');
            const insert = this.db.prepare('INSERT INTO colors (name, is_default) VALUES (?, ?)');
            const defaultColors: [string, number][] = [
                ['Red', 1],
                ['Blue', 0],
                ['Green', 0],
                ['Yellow', 0],
                ['Purple', 0]
            ];
            
            const insertMany = this.db.transaction((colors: [string, number][]) => {
                for (const color of colors) {
                    insert.run(color[0], color[1]);
                }
            });
            
            insertMany(defaultColors);
            console.log('[DatabaseService] Default colors inserted successfully');
        }

        // Create tags table
        this.db.exec(`
            CREATE TABLE IF NOT EXISTS tags (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL CHECK(length(name) <= 40),
                UNIQUE(name)
            )
        `);

        // Create notes table
        this.db.exec(`
            CREATE TABLE IF NOT EXISTS notes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                content TEXT NOT NULL,
                color_id INTEGER NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (color_id) REFERENCES colors(id)
            )
        `);

        // Create note_tags join table
        this.db.exec(`
            CREATE TABLE IF NOT EXISTS note_tags (
                note_id INTEGER,
                tag_id INTEGER,
                PRIMARY KEY (note_id, tag_id),
                FOREIGN KEY (note_id) REFERENCES notes(id) ON DELETE CASCADE,
                FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
            )
        `);

        // Insert default colors if they don't exist
        this.initializeDefaultColors();
    }

    private initializeDefaultColors() {
        const defaultColors = [
            { name: 'light', is_default: true },
            { name: 'pink', is_default: false },
            { name: 'red', is_default: false },
            { name: 'orange', is_default: false },
            { name: 'yellow', is_default: false },
            { name: 'green', is_default: false },
            { name: 'blue', is_default: false },
            { name: 'purple', is_default: false }
        ];

        const insertColor = this.db.prepare(`
            INSERT OR IGNORE INTO colors (name, is_default)
            VALUES (?, ?)
        `);

        const transaction = this.db.transaction((colors: Array<{name: string, is_default: boolean}>) => {
            for (const color of colors) {
                insertColor.run(color.name, color.is_default ? 1 : 0);
            }
        });

        transaction(defaultColors);
    }

    // Helper method to get tags for a note
    private getNoteTags(noteId: number): Tag[] {
        interface DbTag { id: number; name: string; }
        const stmt = this.db.prepare('SELECT t.* FROM tags t JOIN note_tags nt ON t.id = nt.tag_id WHERE nt.note_id = ?');
        const result = stmt.all(noteId) as DbTag[];
        return result.map(tag => ({
            id: tag.id,
            name: tag.name
        }));
    }

    getAllNotes(): Note[] {
        interface DbNote {
            id: number;
            title: string;
            content: string;
            color_id: number;
            created_at: string;
            updated_at: string;
            color_name: string;
            is_default: number;
        }
        
        const stmt = this.db.prepare(`
            SELECT n.*, c.name as color_name, c.is_default 
            FROM notes n
            JOIN colors c ON n.color_id = c.id
            ORDER BY n.created_at DESC
        `);
        const notes = stmt.all() as DbNote[];

        return notes.map(note => ({
            id: note.id,
            title: note.title,
    }
    
    const stmt = this.db.prepare(`
        SELECT n.*, c.name as color_name, c.is_default 
        FROM notes n
        JOIN colors c ON n.color_id = c.id
        WHERE n.id = ?
    `);
    const note = stmt.get(id) as DbNote | undefined;

    if (!note) return undefined;

    return {
        id: note.id,
        title: note.title,
        content: note.content,
        color_id: note.color_id,
        created_at: note.created_at,
        updated_at: note.updated_at,
        color_details: {
            id: note.color_id,
            name: note.color_name,
            is_default: note.is_default === 1
        },
        tags_details: this.getNoteTags(note.id)
    };
}

createNote(note: NoteCreate): Note {
    const { title, content, color_id, tags = [] } = note;
    
    const insertNote = this.db.prepare(`
        INSERT INTO notes (title, content, color_id)
        VALUES (?, ?, ?)
    `);
    
    const insertNoteTag = this.db.prepare(`
        INSERT INTO note_tags (note_id, tag_id)
        VALUES (?, ?)
    `);
    
    const getOrCreateTag = this.db.prepare(`
        INSERT OR IGNORE INTO tags (name) VALUES (?);
        SELECT id FROM tags WHERE name = ?;
    `);
    
    const transaction = this.db.transaction(() => {
        // Insert the note
        const noteInfo = insertNote.run(title, content, color_id);
        const noteId = noteInfo.lastInsertRowid;
            content: note.content,
            color_id: note.color_id,
            created_at: note.created_at,
            updated_at: note.updated_at,
            color_details: {
                id: note.color_id,
                name: note.color_name,
                is_default: note.is_default === 1
            },
            tags_details: this.getNoteTags(note.id)
        };
    }

    createNote(note: NoteCreate): Note {
        const { title, content, color_id, tags = [] } = note;
        
        const insertNote = this.db.prepare(`
            INSERT INTO notes (title, content, color_id)
            VALUES (?, ?, ?)
        `);
        
        const insertNoteTag = this.db.prepare(`
            INSERT INTO note_tags (note_id, tag_id)
            VALUES (?, ?)
        `);
        
        const getOrCreateTag = this.db.prepare(`
            INSERT OR IGNORE INTO tags (name) VALUES (?);
            SELECT id FROM tags WHERE name = ?;
        `);
        
        const transaction = this.db.transaction(() => {
            // Insert the note
            const noteInfo = insertNote.run(title, content, color_id);
            const noteId = noteInfo.lastInsertRowid;
            
            // Process tags
            for (const tagName of tags) {
                const tag = getOrCreateTag.get(tagName, tagName);
                insertNoteTag.run(noteId, tag.id);
            }
            
            return noteId;
        });
        
        const noteId = transaction();
        return this.getNoteById(noteId) as Note;
    }

    updateNote(id: number, note: NoteUpdate): Note | undefined {
        const { title, content, color_id, tags } = note;
        
        // Start a transaction for atomic updates
        const transaction = this.db.transaction(() => {
            // Build the update query dynamically based on provided fields
            const updates: string[] = [];
            const params: any[] = [];
            
            if (title !== undefined) {
                updates.push('title = ?');
                params.push(title);
            }
            
            if (content !== undefined) {
                updates.push('content = ?');
                params.push(content);
            }
            
            if (color_id !== undefined) {
                updates.push('color_id = ?');
                params.push(color_id);
            }
            
            // Always update the updated_at timestamp
            updates.push('updated_at = CURRENT_TIMESTAMP');
            
            // Add the WHERE condition
            params.push(id);
            
            // Execute the update
            const updateQuery = `
                UPDATE notes 
                SET ${updates.join(', ')}
                WHERE id = ?
            `;
            
            this.db.prepare(updateQuery).run(...params);
            
            // If tags are provided, update them
            if (tags) {
                // Remove existing tags
                this.db.prepare('DELETE FROM note_tags WHERE note_id = ?').run(id);
                
                // Add new tags
                const insertNoteTag = this.db.prepare(`
                    INSERT INTO note_tags (note_id, tag_id)
                    VALUES (?, ?)
                `);
                
                const getOrCreateTag = this.db.prepare(`
                    INSERT OR IGNORE INTO tags (name) VALUES (?);
                    SELECT id FROM tags WHERE name = ?;
                `);
                
                for (const tagName of tags) {
                    const tag = getOrCreateTag.get(tagName, tagName);
                    insertNoteTag.run(id, tag.id);
                }
            }
            
            return id;
        });
        
        transaction();
        return this.getNoteById(id);
    }

    deleteNote(id: number): boolean {
        // Due to foreign key constraints with CASCADE, deleting the note will automatically
        // delete the associated note_tags entries
        const stmt = this.db.prepare('DELETE FROM notes WHERE id = ?');
        const info = stmt.run(id);
        return info.changes > 0;
    }

    close(): void {
        this.db.close();
    }
}
